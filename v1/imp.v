Set Warnings "-notation-overridden,-parsing".
From Coq Require Import Bool.Bool.
From Coq Require Import Init.Nat.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.EqNat.
From Coq Require Import omega.Omega.
From Coq Require Import Lists.List.
From Coq Require Import Strings.String.
Import ListNotations.
From LF Require Import maps.

(* Arithmetic and Boolean Expressions *)
Module AExp.

(* abstract syntax of arithmetic and boolean expressions. *)
Inductive aexp : Type :=
| ANum (n : nat)
| APlus (a1 a2 : aexp)
| AMinus (a1 a2 : aexp)
| AMult (a1 a2 : aexp).

Inductive bexp : Type :=
| BTrue
| BFalse
| BEq (a1 a2 : aexp)
| BLe (a1 a2 : aexp)
| BNot (b : bexp)
| BAnd (b1 b2 : bexp).

(* Evaluation *)
Fixpoint aeval (a : aexp) : nat :=
  match a with
  | ANum n => n
  | APlus a1 a2 => (aeval a1) + (aeval a2)
  | AMinus a1 a2 => (aeval a1) - (aeval a2)
  | AMult a1 a2 => (aeval a1) * (aeval a2)
  end.

Example test_aeval1:
  aeval (APlus (ANum 2) (ANum 2)) = 4.
Proof. reflexivity. Qed.

Fixpoint beval (b : bexp) : bool :=
  match b with
  | BTrue => true
  | BFalse => false
  | BEq a1 a2 => (aeval a1) =? (aeval a2)
  | BLe a1 a2 => (aeval a1) <=? (aeval a2)
  | BNot b1 => negb (beval b1)
  | BAnd b1 b2 => andb (beval b1) (beval b2)
  end.

(* Optimization *)

(* changing every occurrence of 0 + e
(i.e., (APlus (ANum 0) e) into just e. *)
Fixpoint optimize_0plus (a:aexp) : aexp :=
  match a with
  | ANum n => ANum n
  | APlus (ANum 0) e2 => optimize_0plus e2
  | APlus e1 e2 => APlus (optimize_0plus e1) (optimize_0plus e2)
  | AMinus e1 e2 => AMinus (optimize_0plus e1) (optimize_0plus e2)
  | AMult e1 e2 => AMult (optimize_0plus e1) (optimize_0plus e2)
  end.
Example test_optimize_0plus:
  optimize_0plus (APlus (ANum 2)
                        (APlus (ANum 0)
                               (APlus (ANum 0) (ANum 1))))
  = APlus (ANum 2) (ANum 1).
Proof. reflexivity. Qed.

Theorem optimize_0plus_sound: forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  induction a.
  - reflexivity.
  - destruct a1 eqn:Ea1.
    + destruct n eqn:En.
      * simpl. apply IHa2.
      * simpl. rewrite IHa2. reflexivity.
    + simpl. simpl in IHa1. rewrite IHa1.
      rewrite IHa2. reflexivity.
    + simpl. simpl in IHa1. rewrite IHa1. rewrite IHa2. reflexivity.
    + simpl. simpl in IHa1. rewrite IHa1. rewrite IHa2. reflexivity.
  - simpl. rewrite IHa1. rewrite IHa2. reflexivity.
  - simpl. rewrite IHa1. rewrite IHa2. reflexivity.
Qed.


(* Coq Automation *)

(* Tacticals *)

(* The "try" Tactical *)
(* If T is a tactic, then try T is a tactic that is just like T except
that, if T fails, try T successfully does nothing at all
(rather than failing).

it is very useful for doing automated proofs in conjunction with the
";" tactical*)

Theorem silly1 : forall ae, aeval ae = aeval ae.
Proof. try reflexivity. (* This just does reflexivity. *) Qed.
Theorem silly2 : forall (P : Prop), P -> P.
Proof.
  intros P HP.
  try reflexivity. (* Just reflexivity would have failed. *)
  apply HP. (* We can still finish the proof in some other way. *)
Qed.

(* The ";" Tactical (Simple Form) *)
(* The compound tactic T;T' first performs T and then performs T'
on each subgoal generated by T. *)

Lemma foo : forall n, 0 <=? n = true.
Proof.
  intros.
  destruct n.
    (* Leaves two subgoals, which are discharged identically...  *)
    - (* n=0 *) simpl. reflexivity.
    - (* n=Sn' *) simpl. reflexivity.
Qed.

Lemma foo' : forall n, 0 <=? n = true.
Proof.
  intros.
  (* destruct the current goal *)
  destruct n;
  (* then simpl each resulting subgoal *)
  simpl;
  (* and do reflexivity on each resulting subgoal *)
  reflexivity.
Qed.

Theorem optimize_0plus_sound': forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros a.
  induction a;
    (* Most cases follow directly by the IH... *)
    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity).
    (* ... but the remaining cases -- ANum and APlus --
       are different: *)
  - (* ANum *) reflexivity.
  - (* APlus *)
    destruct a1 eqn:Ea1;
      (* Again, most cases follow directly by the IH: *)
      try (simpl; simpl in IHa1; rewrite IHa1;
           rewrite IHa2; reflexivity).
    (* The interesting case, on which the try...
       does nothing, is when e1 = ANum n. In this
       case, we have to destruct n (to see whether
       the optimization applies) and rewrite with the
       induction hypothesis. *)
    + (* a1 = ANum n *) destruct n eqn:En;
      simpl; rewrite IHa2; reflexivity. Qed.

Theorem optimize_0plus_sound'': forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros a.
  induction a;
    (* Most cases follow directly by the IH *)
    try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);
    (* ... or are immediate by definition *)
    try reflexivity.
  (* The interesting case is when a = APlus a1 a2. *)
  - (* APlus *)
    destruct a1; try (simpl; simpl in IHa1; rewrite IHa1;
                      rewrite IHa2; reflexivity).
    + (* a1 = ANum n *) destruct n;
      simpl; rewrite IHa2; reflexivity. Qed.

(* ";" tactical in general form *)
(* The ; tactical also has a more general form than the simple T;T' we've seen above.
If T, T1, ..., Tn are tactics, then T; [T1 | T2 | ... | Tn] *)

(*  T;T' is shorthand for: T; [T' | T' | ... | T'] *)

(* the "repeat" tactical *)

(* The repeat tactical takes another tactic and keeps applying
this tactic until it fails. *)
Theorem In10 : In 10 [1;2;3;4;5;6;7;8;9;10].
Proof.
  repeat (try (left; reflexivity); right).
Qed.

(* The tactic repeat T never fails: if the tactic T doesn't apply to the
original goal, then repeat still succeeds without changing the original goal *)

Theorem In10' : In 10 [1;2;3;4;5;6;7;8;9;10].
Proof.
  repeat (left; reflexivity).
  repeat (right; try (left; reflexivity)).
Qed.

(* The tactic repeat T also does not have any upper bound on the number of times
it applies T. If T is a tactic that always succeeds, then repeat T will loop forever
(e.g., repeat simpl loops, since simpl always succeeds) *)

(* Exercise : optimize_0plus_b_sound *)
Fixpoint optimize_0plus_b (b : bexp) : bexp :=
  match b with
  | BTrue => BTrue
  | BFalse => BFalse
  | BEq a1 a2 => BEq (optimize_0plus a1) (optimize_0plus a2)
  | BLe a1 a2 => BLe (optimize_0plus a1) (optimize_0plus a2)
  | BNot b => BNot (optimize_0plus_b b)
  | BAnd b1 b2 => BAnd (optimize_0plus_b b1) (optimize_0plus_b b2)
  end.

Theorem optimize_0plus_b_sound : forall b,
  beval (optimize_0plus_b b) = beval b.
Proof.
  intro b.
  induction b;
    try reflexivity;
    try (simpl; repeat (rewrite optimize_0plus_sound); reflexivity);
    try (simpl; rewrite IHb; reflexivity).
  - simpl. rewrite IHb1. rewrite IHb2. reflexivity.
Qed.

(* Defining New Tactic Notations *)

(* The Tactic Notation idiom illustrated below gives a handy way to define
"shorthand tactics" that bundle several tactics into a single command. *)

Tactic Notation "simpl_and_try" tactic(c) :=
  simpl;
  try c.

(* Coq offers a built-in language called "Ltac" with primitives that can examine
and modify the proof state *)

(* The "Omega" tactic *)
(* The omega tactic implements a decision procedure for a subset of first-order
logic called "Presburger arithmetic" *)

(* If the goal is a universally quantified formula made out of
- numeric constants, addition (+ and S), subtraction (- and pred), and multiplication
  by constants (this is what makes it Presburger arithmetic),
- equality (= and ≠) and ordering (≤), and
- the logical connectives ∧, ∨, ¬, and ->,
then invoking omega will either solve the goal or fail, meaning that the goal
is actually false*)

Example silly_presburger_example : forall m n o p,
  m + n <= n + o /\ o + 3 = p + 3 ->
  m <= p.
Proof.
  intros. omega.
Qed.

(* A Few More Handy Tactics
Finally, here are some miscellaneous tactics that you may find convenient.

- clear H: Delete hypothesis H from the context.
- subst x: For a variable x, find an assumption x = e or e = x in the context,
  replace x with e throughout the context and current goal, and clear the assumption.
- subst: Substitute away all assumptions of the form x = e or e = x
  (where x is a variable).
- rename... into...: Change the name of a hypothesis in the proof context.
  For example, if the context includes a variable named x, then rename x into y
  will change all occurrences of x to y.
- assumption: Try to find a hypothesis H in the context that exactly matches the goal;
  if one is found, behave like apply H.
- contradiction: Try to find a hypothesis H in the current context that is logically
  equivalent to False. If one is found, solve the goal.
- constructor: Try to find a constructor c (from some Inductive definition
  in the current environment) that can be applied to solve the current goal.
  If one is found, behave like apply c.

We'll see examples of all of these as we go along. *)

(* Evaluation as Relation *)

(* Another way to think about evaluation is as a relation between expressions
and their values *)
Module aevalR_first_try.
Inductive aevalR : aexp -> nat -> Prop :=
| E_ANum n :
    aevalR (ANum n) n
| E_APlus (e1 e2: aexp) (n1 n2: nat) :
    aevalR e1 n1 ->
    aevalR e2 n2 ->
    aevalR (APlus e1 e2) (n1 + n2)
| E_AMinus (e1 e2: aexp) (n1 n2: nat) :
    aevalR e1 n1 ->
    aevalR e2 n2 ->
    aevalR (AMinus e1 e2) (n1 - n2)
| E_AMult (e1 e2: aexp) (n1 n2: nat) :
    aevalR e1 n1 ->
    aevalR e2 n2 ->
    aevalR (AMult e1 e2) (n1 * n2).

Module TooHardToRead.
(* A small notational aside. We would previously have written the
    definition of aevalR like this, with explicit names for the
    hypotheses in each case: *)
Inductive aevalR : aexp -> nat -> Prop :=
| E_ANum n :
    aevalR (ANum n) n
| E_APlus (e1 e2: aexp) (n1 n2: nat)
    (H1 : aevalR e1 n1)
    (H2 : aevalR e2 n2) :
    aevalR (APlus e1 e2) (n1 + n2)
| E_AMinus (e1 e2: aexp) (n1 n2: nat)
    (H1 : aevalR e1 n1)
    (H2 : aevalR e2 n2) :
    aevalR (AMinus e1 e2) (n1 - n2)
| E_AMult (e1 e2: aexp) (n1 n2: nat)
    (H1 : aevalR e1 n1)
    (H2 : aevalR e2 n2) :
    aevalR (AMult e1 e2) (n1 * n2).
End TooHardToRead.

Notation "e '\\' n"
         := (aevalR e n)
            (at level 50, left associativity)
         : type_scope.
End aevalR_first_try.

(* Coq provides a way to use this notation in the definition of aevalR itself. *)
Reserved Notation "e '\\' n" (at level 90, left associativity).
Inductive aevalR : aexp -> nat -> Prop :=
  | E_ANum (n : nat) :
      (ANum n) \\ n
  | E_APlus (e1 e2 : aexp) (n1 n2 : nat) :
      (e1 \\ n1) -> (e2 \\ n2) -> (APlus e1 e2) \\ (n1 + n2)
  | E_AMinus (e1 e2 : aexp) (n1 n2 : nat) :
      (e1 \\ n1) -> (e2 \\ n2) -> (AMinus e1 e2) \\ (n1 - n2)
  | E_AMult (e1 e2 : aexp) (n1 n2 : nat) :
      (e1 \\ n1) -> (e2 \\ n2) -> (AMult e1 e2) \\ (n1 * n2)

  where "e '\\' n" := (aevalR e n) : type_scope.

(* Equivalence of Definition *)
Theorem aeval_iff_aevalR : forall a n,
  (a \\ n) <-> aeval a = n.
Proof.
 split.
 - (* -> *)
   intros H.
   induction H; simpl.
   + (* E_ANum *)
     reflexivity.
   + (* E_APlus *)
     rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.
   + (* E_AMinus *)
     rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.
   + (* E_AMult *)
     rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.
 - (* <- *)
   generalize dependent n.
   induction a;
      simpl; intros; subst.
   + (* ANum *)
     apply E_ANum.
   + (* APlus *)
     apply E_APlus.
      apply IHa1. reflexivity.
      apply IHa2. reflexivity.
   + (* AMinus *)
     apply E_AMinus.
      apply IHa1. reflexivity.
      apply IHa2. reflexivity.
   + (* AMult *)
     apply E_AMult.
      apply IHa1. reflexivity.
      apply IHa2. reflexivity.
Qed.

Theorem aeval_iff_aevalR' : forall a n,
  (a \\ n) <-> aeval a = n.
Proof.
  (* WORKED IN CLASS *)
  split.
  - (* -> *)
    intros H; induction H; subst; reflexivity.
  - (* <- *)
    generalize dependent n.
    induction a; simpl; intros; subst; constructor;
       try apply IHa1; try apply IHa2; reflexivity.
Qed.

(* Exercise : bevalR *)

(*  Fixpoint beval (e : bexp) : bool :=
    match e with
    | BTrue       => true
    | BFalse      => false
    | BEq a1 a2   => (aeval a1) =? (aeval a2)
    | BLe a1 a2   => (aeval a1) <=? (aeval a2)
    | BNot b1     => negb (beval b1)
    | BAnd b1 b2  => andb (beval b1) (beval b2)
    end. *)

Inductive bevalR : bexp -> bool -> Prop :=
| E_BTrue : bevalR BTrue true
| E_BFalse : bevalR BFalse false
| E_BEq (a1 a2 : aexp) (n1 n2 : nat) :
    (a1 \\ n1) -> (a2 \\ n2) -> bevalR (BEq a1 a2) (n1 =? n2)
| E_BLe (a1 a2 : aexp) (n1 n2 : nat) :
    a1 \\ n1 -> a2 \\ n2 -> bevalR (BLe a1 a2) (n1 <=? n2)
| E_BNot (b1 : bexp) (b : bool) :
    bevalR b1 b -> bevalR (BNot b1) (negb b)
| E_BAnd (be1 be2 : bexp) (b1 b2 : bool) :
    bevalR be1 b1 -> bevalR be2 b2 -> bevalR (BAnd be1 be2) (andb b1 b2).

Lemma beval_iff_bevalR : forall b bv,
  bevalR b bv <-> beval b = bv.
Proof.
  intros b bv. split.
  - intros H.
    induction H;
      simpl;
      try (apply aeval_iff_aevalR in H; apply aeval_iff_aevalR in H0);
      subst;
      try reflexivity.
  - generalize dependent bv.
    induction b; intros; simpl; subst; simpl; constructor;
      try (apply aeval_iff_aevalR; reflexivity);
      try apply IHb;
      try apply IHb1;
      try apply IHb2;
      reflexivity.
Qed.

End AExp.

(* Computational vs. Relational Definitions *)

(* there are circumstances where relational definitions of evaluation work much better
than functional ones. *)

Module aevalR_division.

Inductive aexp : Type :=
  | ANum (n : nat)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp)
  | ADiv (a1 a2 : aexp).

(* Extending the definition of aeval to handle this new operation would not be
straightforward (what should we return as the result of ADiv (ANum 5) (ANum 0)?).
But extending aevalR is straightforward. *)

Reserved Notation "e '\\' n"
                  (at level 90, left associativity).
Inductive aevalR : aexp -> nat -> Prop :=
  | E_ANum (n : nat) :
      (ANum n) \\ n
  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -> (a2 \\ n2) -> (APlus a1 a2) \\ (n1 + n2)
  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -> (a2 \\ n2) -> (AMinus a1 a2) \\ (n1 - n2)
  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -> (a2 \\ n2) -> (AMult a1 a2) \\ (n1 * n2)
  | E_ADiv (a1 a2 : aexp) (n1 n2 n3 : nat) :
      (a1 \\ n1) -> (a2 \\ n2) -> (n2 > 0) ->
      (mult n2 n3 = n1) -> (ADiv a1 a2) \\ n3

where "a '\\' n" := (aevalR a n) : type_scope.
End aevalR_division.

Module aevalR_extended.

(* extend the arithmetic operations by a nondeterministic number generator any that,
when evaluated, may yield any number *)
Reserved Notation "e '\\' n" (at level 90, left associativity).
Inductive aexp : Type :=
  | AAny (* <--- NEW *)
  | ANum (n : nat)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).

Inductive aevalR : aexp -> nat -> Prop :=
  | E_Any (n : nat) :
      AAny \\ n (* <--- NEW *)
  | E_ANum (n : nat) :
      (ANum n) \\ n
  | E_APlus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -> (a2 \\ n2) -> (APlus a1 a2) \\ (n1 + n2)
  | E_AMinus (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -> (a2 \\ n2) -> (AMinus a1 a2) \\ (n1 - n2)
  | E_AMult (a1 a2 : aexp) (n1 n2 : nat) :
      (a1 \\ n1) -> (a2 \\ n2) -> (AMult a1 a2) \\ (n1 * n2)

where "a '\\' n" := (aevalR a n) : type_scope.
End aevalR_extended.


(* Expresssions with variables *)

(* States  
- assume that all variables are global and that they only hold numbers.
- assume that the state is defined for all variables *)

Definition state := total_map nat.

(* Syntax *)
Inductive aexp : Type :=
  | ANum (n : nat)
  | AId (x : string) (* <--- NEW *)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).

Definition W : string := "W".
Definition X : string := "X".
Definition Y : string := "Y".
Definition Z : string := "Z".

Inductive bexp : Type :=
  | BTrue
  | BFalse
  | BEq (a1 a2 : aexp)
  | BLe (a1 a2 : aexp)
  | BNot (b : bexp)
  | BAnd (b1 b2 : bexp).

(* Notations *)

(* Briefly, though, the "Coercion" declaration in Coq stipulates that a function
(or constructor) can be implicitly used by the type system to coerce a value of
the input type to a value of the output type *)

Coercion AId : string >-> aexp.
Coercion ANum : nat >-> aexp.
Definition bool_to_bexp (b : bool) : bexp :=
  if b then BTrue else BFalse.
Coercion bool_to_bexp : bool >-> bexp.
Bind Scope imp_scope with aexp.
Bind Scope imp_scope with bexp.
Delimit Scope imp_scope with imp.
Notation "x + y" := (APlus x y) (at level 50, left associativity) : imp_scope.
Notation "x - y" := (AMinus x y) (at level 50, left associativity) : imp_scope.
Notation "x * y" := (AMult x y) (at level 40, left associativity) : imp_scope.
Notation "x <= y" := (BLe x y) (at level 70, no associativity) : imp_scope.
Notation "x = y" := (BEq x y) (at level 70, no associativity) : imp_scope.
Notation "x && y" := (BAnd x y) (at level 40, left associativity) : imp_scope.
Notation "'~' b" := (BNot b) (at level 75, right associativity) : imp_scope.
Definition example_aexp := (3 + (X * 2))%imp : aexp.
Definition example_bexp := (true && ~(X <= 4))%imp : bexp.

Set Printing Coercions.
Print example_bexp.
(* ===> example_bexp = bool_to_bexp true && ~ (AId X <= ANum 4) *)
Unset Printing Coercions.

(* Evaluation *)
Fixpoint aeval (st : state) (a : aexp) : nat :=
  match a with
  | ANum n => n
  | AId x => st x (* <--- NEW *)
  | APlus a1 a2 => (aeval st a1) + (aeval st a2)
  | AMinus a1 a2 => (aeval st a1) - (aeval st a2)
  | AMult a1 a2 => (aeval st a1) * (aeval st a2)
  end.

Fixpoint beval (st : state) (b : bexp) : bool :=
  match b with
  | BTrue => true
  | BFalse => false
  | BEq a1 a2 => (aeval st a1) =? (aeval st a2)
  | BLe a1 a2 => (aeval st a1) <=? (aeval st a2)
  | BNot b1 => negb (beval st b1)
  | BAnd b1 b2 => andb (beval st b1) (beval st b2)
  end.

Definition empty_st := (_ !-> 0).
(* notation for a "singleton state" with just one variable bound to a value. *)
Notation "a '!->' x" := (t_update empty_st a x) (at level 100).

Example aexp1 : aeval (X !-> 5) (3 + (X * 2))%imp = 13.
Proof. reflexivity. Qed.

Example bexp1 : beval (X !-> 5) (true && ~(X <= 4))%imp = true.
Proof. reflexivity. Qed.

(* Commands (Statements) *)

(* Syntax *)

(* commands c are described by the following BNF grammar.
c ::= SKIP | x ::= a | c ;; c | TEST b THEN c ELSE c FI | WHILE b DO c END *)
Inductive com : Type :=
  | CSkip
  | CAss (x : string) (a : aexp)
  | CSeq (c1 c2 : com)
  | CIf (b : bexp) (c1 c2 : com)
  | CWhile (b : bexp) (c : com).

Bind Scope imp_scope with com.
Notation "'SKIP'" := CSkip : imp_scope.
Notation "x '::=' a" := (CAss x a)
  (at level 60) : imp_scope.
Notation "c1 ;; c2" := (CSeq c1 c2)
  (at level 80, right associativity) : imp_scope.
Notation "'WHILE' b 'DO' c 'END'" := (CWhile b c)
  (at level 80, right associativity) : imp_scope.
Notation "'TEST' c1 'THEN' c2 'ELSE' c3 'FI'" := (CIf c1 c2 c3)
  (at level 80, right associativity) : imp_scope.

Definition fact_in_coq : com :=
  (Z ::= X;;
  Y ::= 1;;
  WHILE ~(Z = 0) DO
    Y ::= Y * Z;;
    Z ::= Z - 1
  END)%imp.

(* Desugaring Notations
- Unset Printing Notations (undo with Set Printing Notations)
- Set Printing Coercions (undo with Unset Printing Coercions)
- Set Printing All (undo with Unset Printing All) *)

Unset Printing Notations.
Print fact_in_coq.
Set Printing Notations.

(* "Locate" Command *)
(* When faced with unknown notation, use "Locate" with a string containing one of
its symbols to see its possible interpretations. *)

Locate "&&".
Locate ";;".
Locate "WHILE".
Locate aexp.

(* Examples *)
Definition plus2 : com :=
  X ::= X + 2.
Definition XtimesYinZ : com :=
  Z ::= X * Y.
Definition subtract_slowly_body : com :=
  Z ::= Z - 1 ;;
  X ::= X - 1.

Definition subtract_slowly : com :=
  (WHILE ~(X = 0) DO
    subtract_slowly_body
  END)%imp.
Definition subtract_3_from_5_slowly : com :=
  X ::= 3 ;;
  Z ::= 5 ;;
  subtract_slowly.

Definition loop : com :=
WHILE true DO
  SKIP
END.

(* Evaluating Commands : 
The fact that WHILE loops don't necessarily terminate makes defining an evaluation
function tricky*)

(* Failed Attempt - omitting "WHILE" case *)
(* Since Coq is not just a functional programming language but also a consistent logic,
any potentially non-terminating function needs to be rejected *)
Open Scope imp_scope.
Fixpoint ceval_fun_no_while (st : state) (c : com) : state :=
  match c with
    | SKIP => st
    | x ::= a1 => (x !-> (aeval st a1) ; st)
    | c1 ;; c2 =>
      let st' := ceval_fun_no_while st c1 in
        ceval_fun_no_while st' c2
    | TEST b THEN c1 ELSE c2 FI =>
      if (beval st b)
        then ceval_fun_no_while st c1
        else ceval_fun_no_while st c2
    | WHILE b DO c END =>
        st (* bogus *)
    (* WHILE b DO c END =>
                if (beval st b)
                  then ceval_fun st (c ;; WHILE b DO c END)
                  else st -> it doesn't work! *)
  end.
Close Scope imp_scope.


(* if Coq allowed non-terminating recursive functions:
    Fixpoint loop_false (n : nat) : False := loop_false n.
That is, propositions like False would become provable (loop_false 0 would be a
proof of False), which would be a disaster for Coq's logical consistency. *)

(* Evaluation as a Relation *)

(* "st =[ c ]=> st'" means that executing program c in a starting state st results
in an ending state st' *)

Reserved Notation "st '=[' c ']=>' st'"
                  (at level 40).
Inductive ceval : com -> state -> state -> Prop :=
  | E_Skip : forall st,
      st =[ SKIP ]=> st
  | E_Ass : forall st a1 n x,
      aeval st a1 = n ->
      st =[ x ::= a1 ]=> (x !-> n ; st)
  | E_Seq : forall c1 c2 st st' st'',
      st =[ c1 ]=> st' ->
      st' =[ c2 ]=> st'' ->
      st =[ c1 ;; c2 ]=> st''
  | E_IfTrue : forall st st' b c1 c2,
      beval st b = true ->
      st =[ c1 ]=> st' ->
      st =[ TEST b THEN c1 ELSE c2 FI ]=> st'
  | E_IfFalse : forall st st' b c1 c2,
      beval st b = false ->
      st =[ c2 ]=> st' ->
      st =[ TEST b THEN c1 ELSE c2 FI ]=> st'
  | E_WhileFalse : forall b st c,
      beval st b = false ->
      st =[ WHILE b DO c END ]=> st
  | E_WhileTrue : forall st st' st'' b c,
      beval st b = true ->
      st =[ c ]=> st' ->
      st' =[ WHILE b DO c END ]=> st'' ->
      st =[ WHILE b DO c END ]=> st''

  where "st =[ c ]=> st'" := (ceval c st st').

(* The cost of defining evaluation as a relation instead of a function is that we
now need to construct proofs that some program evaluates to some result state,
rather than just letting Coq's computation mechanism do it for us. *)

Example ceval_example1:
  empty_st=[
     X ::= 2;;
     TEST X <= 1
       THEN Y ::= 3
       ELSE Z ::= 4
     FI
  ]=> (Z !-> 4 ; X !-> 2).
Proof.
  (* We must supply the intermediate state *)
  apply E_Seq with (X !-> 2).
  - (* assignment command *)
    apply E_Ass. reflexivity.
  - (* if command *)
    apply E_IfFalse.
    reflexivity.
    apply E_Ass. reflexivity.
Qed.

(* Exercise : ceval_example2 *)
Example ceval_example2:
  empty_st =[
    X ::= 0;; Y ::= 1;; Z ::= 2
  ]=> (Z !-> 2 ; Y !-> 1 ; X !-> 0).
Proof.
  apply E_Seq with (X !-> 0).
  - apply E_Ass. reflexivity.
  - apply E_Seq with (Y !-> 1; X !->0).
    + apply E_Ass. reflexivity.
    + apply E_Ass. reflexivity.
Qed.

(* Exercise : pup_to_n *)
(* sums the numbers from 1 to X (inclusive: 1 + 2 + ... + X) in the variable Y *)
Definition pup_to_n : com := (
  Y ::= 0 ;;
  WHILE ~ (0 = X) DO
    Y ::= Y + X ;;
    X ::= X - 1
  END
)%imp.

Theorem pup_to_2_ceval :
  (X !-> 2) =[
    pup_to_n
  ]=> (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2).
Proof.
  unfold pup_to_n.
  apply E_Seq with (Y !-> 0; X!->2).
  - apply E_Ass. reflexivity.
  - apply E_WhileTrue with
      (st':= (X!->1;Y!->2;Y!->0; X!->2))
      (st'':= (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2)).
    + simpl. reflexivity.
    + apply E_Seq with (Y !-> 2 ; Y !-> 0 ; X !-> 2).
      { apply E_Ass. simpl. reflexivity. }
      { apply E_Ass. simpl. reflexivity. }
    + apply E_WhileTrue with
        (st':= (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2))
        (st'':= (X !-> 0 ; Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2)).
      { simpl. reflexivity. }
      { apply E_Seq with (Y !-> 3 ; X !-> 1 ; Y !-> 2 ; Y !-> 0 ; X !-> 2).
      - apply E_Ass. simpl. reflexivity.
      - apply E_Ass. simpl. reflexivity. }
      { apply E_WhileFalse. simpl. reflexivity.  }
Qed.

(* Determinism of Evaluation *)

(* Changing from a computational to a relational definition of evaluation is a
good move because it frees us from the artificial requirement that evaluation
should be a total function *)

(* beginning from the same state st, we could evaluate some command c in different
ways to reach two different output states st' and st''?
In fact, this cannot happen: ceval is a partial function: *)

Theorem ceval_deterministic: forall c st st1 st2,
     st =[ c ]=>  st1 ->
     st =[ c ]=>  st2 ->
     st1 = st2.
Proof.
  intros c st st1 st2 E1 E2.
  generalize dependent st2.
  induction E1;
           intros st2 E2; inversion E2; subst;
           try reflexivity.
  (* - E_Skip reflexivity.
  - (* E_Ass *) reflexivity. *)
  - (* E_Seq *)
    assert (st' = st'0) as EQ1.
    { (* Proof of assertion *) apply IHE1_1; assumption. }
    subst st'0.
    apply IHE1_2. assumption.
  - (* E_IfTrue, b1 evaluates to true *)
      apply IHE1. assumption.
  - (* E_IfTrue,  b1 evaluates to false (contradiction) *)
      rewrite H in H5. discriminate H5.
  - (* E_IfFalse, b1 evaluates to true (contradiction) *)
      rewrite H in H5. discriminate H5.
  - (* E_IfFalse, b1 evaluates to false *)
      apply IHE1. assumption.
  (* - E_WhileFalse, b1 evaluates to false
    reflexivity. *)
  - (* E_WhileFalse, b1 evaluates to true (contradiction) *)
    rewrite H in H2. discriminate H2.
  - (* E_WhileTrue, b1 evaluates to false (contradiction) *)
    rewrite H in H4. discriminate H4.
  - (* E_WhileTrue, b1 evaluates to true *)
      assert (st' = st'0) as EQ1.
      { (* Proof of assertion *) apply IHE1_1; assumption. }
      subst st'0.
      apply IHE1_2. assumption. Qed.

(* Reasoning about imp programs *)
Theorem plus2_spec : forall st n st',
  st X = n ->
  st =[ plus2 ]=>  st' ->
  st' X = n + 2.
Proof.
  intros st n st' HX Heval.
  inversion Heval. subst. clear Heval. simpl.
  apply t_update_eq.
Qed.

(* Exercise : XtimesYinZ spec *)
Theorem XtimesYinZ_spec: forall st nx ny st',
  st X = nx -> st Y = ny ->
  st =[XtimesYinZ]=> st' ->
  st' Z = nx * ny.
Proof.
  intros st nx ny st' Hx Hy Heval.
  inversion Heval. subst. simpl.
  apply t_update_eq.
Qed.

(* Exercise : loop_never_stops *)
Theorem loop_never_stops : forall st st',
  ~(st =[ loop ]=> st').
Proof.
  intros st st' contra. unfold loop in contra.
  remember (WHILE true DO SKIP END)%imp as loopdef
           eqn:Heqloopdef.
  induction contra; try discriminate Heqloopdef.
  - destruct b; try (simpl; discriminate H); try discriminate Heqloopdef.
  - apply IHcontra2 in Heqloopdef. contradiction.
Qed.

(* Exercise : no_whiles_eqv *)
Open Scope imp_scope.
Fixpoint no_whiles (c : com) : bool :=
  match c with
  | SKIP => true
  | _ ::= _ => true
  | c1 ;; c2 => andb (no_whiles c1) (no_whiles c2)
  | TEST _ THEN ct ELSE cf FI => andb (no_whiles ct) (no_whiles cf)
  | WHILE _ DO _ END => false
  end.
Close Scope imp_scope.

(* Inductive com : Type :=
  | CSkip
  | CAss (x : string) (a : aexp)
  | CSeq (c1 c2 : com)
  | CIf (b : bexp) (c1 c2 : com)
  | CWhile (b : bexp) (c : com). *)

Inductive no_whilesR: com -> Prop :=
| no_while_SKIP : no_whilesR SKIP
| no_while_Ass (x : string)(a : aexp): no_whilesR (CAss x a)
| no_while_Seq (c1 c2 : com) :
    no_whilesR c1 -> no_whilesR c2 -> no_whilesR (CSeq c1 c2)
| no_while_If (b : bexp) (c1 c2 : com) :
    no_whilesR c1 -> no_whilesR c2 -> no_whilesR (CIf b c1 c2)
| no_while_While (b: bexp) (c : com) : False -> no_whilesR (CWhile b c).

Theorem no_whiles_eqv:
  forall c, no_whiles c = true <-> no_whilesR c.
Proof.
  intros c. split.
  (* -> *)
  { 
    intros H. induction c.
    - apply no_while_SKIP.
    - apply no_while_Ass.
    - apply no_while_Seq.
      + apply IHc1. simpl in H. unfold andb in H.
        destruct (no_whiles c1) eqn:E.
        * reflexivity.
        * discriminate H.
      + apply IHc2. simpl in H. unfold andb in H.
        destruct (no_whiles c1) eqn:E.
        * assumption.
        * discriminate H.
    - apply no_while_If.
      + apply IHc1. simpl in H. unfold andb in H.
        destruct (no_whiles c1) eqn:E.
        * reflexivity.
        * discriminate H.
      + apply IHc2. simpl in H. unfold andb in H.
        destruct (no_whiles c1) eqn:E.
        * assumption.
        * discriminate H.
    - simpl in H. discriminate H.
  }
  {
    (* <- *)
    intros H. induction H; try reflexivity.
    - simpl. rewrite IHno_whilesR1. rewrite IHno_whilesR2. reflexivity.
    - simpl. rewrite IHno_whilesR1. rewrite IHno_whilesR2. reflexivity.
    - destruct H.
  }
Qed.

(* Exercise : no_whiles_terminating *)
(* Imp programs that don't involve while loops always terminate *)
Theorem no_whiles_terminating: forall c,
  no_whilesR c -> exists st st', st=[c]=>st'.
Proof.
Admitted.
